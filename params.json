{
  "name": "Responsible Gaming",
  "tagline": "Spike in the cloud",
  "body": "## Introduction\r\n\r\nThis project is meant for those who want to create an API with DDD principles in mind.<br>\r\nIt is separated in layers and, within each layer, the responsibilities are grouped in folders.\r\n\r\n## Scope of the project\r\n\r\nEven though this project just wants to serve as an example, it is important to provide with some context to understand what is trying to solve.\r\n\r\nThe project initially arose as a need to regulate compulsive gambling. Basically, it allows customers to create **deposit limits** and **self-exclusions** within a period of time.<br> \r\nFor example, imagine that a customer wants to limit the amount of money he can deposit in his account to a maximum of 100USD per week. Or imagine that this customer directly prefers to not be able to login in his account losing therefore the chance to see what's going on in the page.<br>\r\nOr imagine that he doesn't even want to receive marketing campaigns in his mailbox.<br>\r\n\r\nYou will agree with me that the ability for the customer to apply these rules definitely attenuates his impulses to gamble and promotes auto-control.\r\n\r\n## Project structure\r\n\r\nThe **Api layer** does all the work around **resources**.<br>\r\nIf you look at the controllers, you will see that each controller represents a resource.<br>\r\nThere, you can also see that each resource can support multiple Http Verbs (GET, POST, PUT, DELETE)\r\n\r\nThe **Application layer** does all the work around **intents**.<br>\r\nIntents are reflected as requests in the code. There could be as many requests as the application requires.\r\n\r\nThe **Domain layer** does all the work around **models**.<br>\r\nAs described in the onion architecture or any domain-centric solution, this is the layer where all the other layers start from.\r\n\r\nThe **Infrastructure layer** does the integration with infrastructure matters. These could be databases, queues, files and so on.<br>\r\n\r\n## Validation\r\n\r\nValidation intrinsically affects two layers - The Application layer and the Domain layer.\r\n\r\nImagine that there are a total of two developers collaborating in the project. One is the domain expert and the other knows how the application must behave (this includes knowing the intents of the user along the application).\r\n\r\nDeveloper A, while developing the Domain layer, needs to make sure that no business rule is violated.<br>\r\nIf a rule is violated, a custom exception of the type **ConflictException** must be thrown.<br>\r\nUltimately, this exception will be transformed by the API into a Http Error Code of type **409 Conflict**\r\n\r\nDeveloper B, while developing the Application layer, needs to make sure that requests are properly formed. This includes standard validations like making sure the properties are well formatted and satisfy an specific range. The goal is to never let entities from the next layer be in an invalid state.<br>\r\n**FluentValidation** enormously helps with these type of validations. Something that I like from this library is that it allows the validation to happen even before the request reaches the controller.<br>\r\nIn this case, the API transforms these validations into **400 Bad request**\r\n\r\nIf you are wondering why 409 is preferred over 400 in the Domain, the reasoning is that 400 explicitly says in its description that the request is malformed and, therefore, should not be re-sent without modifications. However, 409  says that the conflict is intrinsic to the current state and, therefore, could go away. \r\nThis leaves us with the following basic Http Codes:\r\n\r\n<table>\r\n<tr><td>GET</td><td>200, 404, 500 </td></tr>\r\n<tr><td>POST</td><td>201, 400, 404, 409, 500</td></tr>\r\n<tr><td>PUT</td><td>204, 400, 404, 409, 500</td></tr>\r\n<tr><td>DELETE</td><td>204, 400, 404, 409, 500</td></tr>\r\n</table>\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}